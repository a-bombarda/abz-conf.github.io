<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Methods | ABZ</title><link>/methods/</link><atom:link href="/methods/index.xml" rel="self" type="application/rss+xml"/><description>Methods</description><generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><copyright>Copyright Â© 2021 ABZ Conference</copyright><image><url>/img/https:/github.com/abz-conf/abz-conf.logo/raw/master/obj/rect/256.png</url><title>Methods</title><link>/methods/</link></image><item><title>Abstract State Machine (ASM)</title><link>/method/asm/</link><pubDate>Wed, 16 Jun 2021 00:00:00 +0000</pubDate><guid>/method/asm/</guid><description>&lt;p>The ASM method applies Abstract State Machines (ASMs) to support &lt;strong>&lt;em>traceable rigorous design and analysis&lt;/em>&lt;/strong> (by experimental testing and/or mathematical verification) of software-intensive systems.
The following &lt;strong>&lt;em>three ingredients&lt;/em>&lt;/strong> of the method support to &lt;strong>&lt;em>develop executable code from specifications by stepwise refinement&lt;/em>&lt;/strong> where at each step both mathematical verification of desired properties and experimental model validation by testing can be applied and fully documented to permit design for change.&lt;/p>
&lt;!-- @ppaulweber: update "the concept ..." -->
&lt;ul>
&lt;li>
&lt;h2 id="the-concept-of-asm">the concept of ASM&lt;/h2>
&lt;p>defined in [1], a semantically well-founded and arguably most general form of conceptually executable pseudo-code.
The definition provides a uniform language to express any intended computational system at any development stage in terms of operations at an appropriate level of abstraction operating directly over objects (read: the system STATE, including input and output) determined by that level of abstraction.&lt;/p>
&lt;/li>
&lt;li>
&lt;h2 id="the-concept-of-asm-ground-model">the concept of ASM ground model&lt;/h2>
&lt;p>defined in [2], i.e. a rigorous requirements model that is expressed in application domain terms.
A ground model ASM turns natural language requirements into a mathematical form that supports the inspection of the model by both domain and software experts, whereby the intended correctness and completeness of the requirements can be effectively checked and documented.&lt;/p>
&lt;/li>
&lt;li>
&lt;h2 id="the-concept-of-asm-refinement">the concept of ASM refinement&lt;/h2>
&lt;p>defined in [3]. It permits to develop a system in well-documented controllable modular steps, linking ASMs at different levels of abstraction, say an abstract and a more detailed model, in a way the software engineer can justify as correct implementation step.
The executability of ASMs supports using testing methods to validate the models whereas their mathematical nature allows one to adopt mathematical verification techniques where appropriate.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>The entire set of refinement steps transforms a ground model into well-documented executable code.
The model analysis at different levels of abstraction helps to avoid and to identify and correct fundamental design errors, which are difficult to detect and expensive to correct in code.
The intermediate models also support model reuse and design (programming) for change.&lt;/p>
&lt;p>Note that the development process is by no means linear, as is illustrated by the following diagram:&lt;/p>
&lt;p>&lt;img src="overview.svg" alt="">&lt;/p>
&lt;p>For an introductory &lt;strong>text book&lt;/strong> with lecture slides see the &lt;em>Modeling Book&lt;/em> [4] or the &lt;em>Asm Book&lt;/em> [5].&lt;/p>
&lt;p>For &lt;strong>case studies&lt;/strong> which illustrate typical applications of the method see the JBook [6] and provided
&lt;a href="/case-studies">case studies&lt;/a> on this page.&lt;/p>
&lt;p>For &lt;strong>tools&lt;/strong> which support the ASM method see&lt;/p>
&lt;ul>
&lt;li>
&lt;a href="https://asmeta.github.io/" target="_blank" rel="noopener">Asmeta&lt;/a>&lt;/li>
&lt;li>
&lt;a href="https://casm-lang.org/" target="_blank" rel="noopener">CASM&lt;/a>&lt;/li>
&lt;li>
&lt;a href="https://github.com/CoreASM" target="_blank" rel="noopener">CoreASM&lt;/a>&lt;/li>
&lt;li>
&lt;a href="https://tydo.eu/AsmGofer" target="_blank" rel="noopener">AsmGofer&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>For the &lt;strong>early history&lt;/strong> &amp;ndash; of the development of the method and early applications in various fields of computer science &amp;ndash; up to 2003 see [7] (available from &lt;a href="https://www.jucs.org/jucs_8_1/the_origins_and_the/Boerger_E.pdf">https://www.jucs.org/jucs_8_1/the_origins_and_the/Boerger_E.pdf&lt;/a>) and &lt;a href="http://web.eecs.umich.edu/gasm/subjects/montage.html">http://web.eecs.umich.edu/gasm/subjects/montage.html&lt;/a>.&lt;/p>
&lt;p>The &lt;strong>epistemological motivation&lt;/strong> for the definition of ASMs was to improve Turing&amp;rsquo;s thesis, which has been proved in [2] from three natural axioms for sequential algorithms.
For the further development of such axiomatic and corresponding ASM-characterizations of algorithmic concepts (e.g. recursive algorithms, reflective algorithms, synchronous parallel algorithms, concurrent algorithms, communicating algorithms, etc.) see [9].
In practice, this so-called behavioral theory of ASMs supports the arguably most general form of ASMs as system specification.&lt;/p>
&lt;p>The &lt;strong>ASM Workshop Proceedings&lt;/strong> 1994-2007 (preceding the merge of those workshops with the user meetings of Z and B to the ABZ Conference, started in 2008):&lt;/p>
&lt;pre>&lt;code>@Proceedings{Asm94,
title = {Technology and {F}oundations. {I}nformation {P}rocessing'94},
year = {1994},
editor = {B. Pehrson and I. Simon},
volume = {{I}, Track 4, Stream C: Evolving Algebras},
series = {},
pages={ 377--441},
publisher = {Elsevier},
address = {Hamburg (Germany)},
note = {Contains Proceedings of First ASM Workshop}
}
@Proceedings{Asm98,
title = {Fifth {I}nternational {W}orkshop on {A}bstract {S}tate {M}achines},
year = {1998},
editor = {U.Gl\&amp;quot;asser and P.Schmitt},
volume = {},
series = {},
publisher = {Otto-von-Guericke-Universit\&amp;quot;at},
address = {Magdeburg (Germany)},
pages = {III+158},
note = {Contains Proceedings of Fifth International ASM Workshop at Informatik'98}
}
@Proceedings{Asm00,
title = {Abstradt {S}tate {M}achines. {T}heory and {A}pplications},
year = {2000},
editor = {Y.Gurevich and P.W.Kutter and M.Odersky and L.Thiele},
volume = {1912},
series = {LNCS},
publisher = {Springer},
address = {Monte Verit\`a (Switzerland)},
note = {Proceedings of 7th International ASM Workshop}
}
@Proceedings{Asm01,
title = {Formal Methods and Tools for Computer Science. Eurocast 2001},
year = {2001},
editor = {R.Moreno-Diaz and A.Quesada-Arencibia},
volume = {},
series = {},
publisher = {IUCTC Universida de Las Palmas de Gran Canaria},
address = {Las Palmas (Spain)},
note = {Contains Extended Abstracts of 8th ASM Workshop. For selected full workshop papers see \cite{BoeGla01}.}
}
@Book{Asm02,
editor = {A.Blass and E.B\&amp;quot;orger and Y.Gurevich},
title = {Theory and Application of Abstract State Machines},
publisher = {Schloss Dagstuhl},
year = {2002},
note = {Seminar Report 336. \url{https://www.dagstuhl.de/02101}}
}
@Proceedings{Asm03,
title = {{Abstract State Machines} 2003. Advances in {T}heory and {P}ractice},
year = {2003},
editor = {E.B\&amp;quot;orger and A.Gargantini and E.Riccobene},
volume = {2589},
series = {LNCS},
publisher = {Springer},
address = {},
note = {Contains Proceedings of 10th ASM Workshop (Taormina, Italy). For a selection of extended workshop papers see \cite{Asm03Tcs}.}
}
@BOOK{Asm03Tcs,
EDITOR = {E.B\&amp;quot;orger},
TITLE = {Abstract {S}tate {M}achines and high-level system design and analysis},
YEAR = {2005},
PUBLISHER = {Elsevier},
SERIES = {Theoretical Computer Science (Special Issue)},
VOLUME = {336 (2--3) },
note = {ISSN 0304--3975. Selection of extended papers from ASM'03 (Taormina, Sicily)}
}
@Proceedings{Asm04,
title = {{Abstract State Machines} 2004. Advances in {T}heory and {P}ractice},
year = {2004},
editor = {W.Zimmermann and B.Thalheim},
volume = {3052},
series = {LNCS},
publisher = {Springer},
address = {},
note = {Contains Proceedings of 11th ASM Workshop (Lutherstadt Wittenberg)}
}
@Misc{Asm05,
author = {E.B\&amp;quot;orger and D. Beauquier and A. Slissenko},
title = {Proc. 12th International Workshop on {A}bstract {S}tate {M}achines
{ASM}'05},
howpublished = { Universit\'e Paris 12 (France)},
year = {2005},
pages ={424},
note = {For a selection of extended workshop papers see \cite{Asm05FI}}
}
@BOOK{Asm05FI,
EDITOR = {E.B\&amp;quot;orger},
TITLE = {The {A}bstract {S}tate {M}achines method},
YEAR = {2007},
PUBLISHER = {IOS Press},
SERIES = {Fundamenta Informaticae (Special Issue)},
VOLUME = {77},
note = {ISSN 0169--2968. Selection of extended papers from ASM'05 (Paris)}
}
@BOOK{Asm07,
EDITOR = {E.B\&amp;quot;orger and A.Prinz},
TITLE = {Quo vadis {A}bstract {S}tate {M}achines?},
YEAR = {2008},
PUBLISHER = {},
SERIES = {J. Universal Computer Science (Special Issue)},
VOLUME = {14 (12)},
pages = {1921--2071},
note = {Selection of extended papers from ASM'07 (Grimstadt, Norway)}
}
&lt;/code>&lt;/pre>
&lt;h2 id="references">REFERENCES&lt;/h2>
&lt;pre>&lt;code>[1] @InCollection{Gurevich94b,
author = {Y. Gurevich},
title = {{Evolving algebras 1993: Lipari Guide}},
booktitle = {Specification and Validation Methods},
publisher = {Oxford University Press},
year = {1995},
pages = {9--36},
editor = {E. B{\&amp;quot;o}rger}}
[2] @InProceedings{Boerger03a,
author = {E. B{\&amp;quot;o}rger},
title = {The {ASM} ground model method as a foundation of requirements engineering},
booktitle = {Verification: Theory and Practice},
pages = {145-160},
year = {2003},
editor = {N.Dershowitz},
volume = {2772},
series = {LNCS},
publisher = {Springer-Verlag}}
[3]
@Article{Boerger02b,
author = {E. B{\&amp;quot;o}rger},
title = {The {ASM} Refinement Method},
journal = {Formal Aspects of Computing},
volume = {15},
year = {2003},
pages = {237-257}}
[4] @Book{BoeRas18,
author = {E. B{\&amp;quot;o}rger and A. Raschke},
title = {Modeling Companion for Software Practitioners},
publisher = {Springer},
year = {2018},
note = {ISBN 978-3-662-56641-1. For Corrigenda and lecture material on themes treated in the book
see \url{http://modelingbook.informatik.uni-ulm.de}}
[5] @Book{BoeSta03,
author = {E. B{\&amp;quot;o}rger and R. F. St{\&amp;quot;a}rk},
title = {Abstract {S}tate {M}achines. A Method for High-Level System
Design and Analysis},
publisher = {Springer},
year = {2003}}
[6] @Book{StScBo01,
author = {R. F. St{\&amp;quot;a}rk and J. Schmid and E. B{\&amp;quot;o}rger},
title = {Java and the Java Virtual Machine: Definition,
Verification, Validation},
publisher = {Springer-Verlag},
year = {2001}}
[7] @Article{Boerger02a,
author = {E. B{\&amp;quot;o}rger},
title = {The Origins and the Development of the {ASM} Method
for High-Level System Design and Analysis},
journal = {J.~Universal Computer Science},
volume = {8},
number = {1},
year = {2002},
pages = {2--74}}
[8] @Article{Gurevich00,
author = {Y. Gurevich},
title = {Sequential {Abstract State Machines} Capture Sequential
Algorithms},
journal = {ACM Trans. Computational Logic},
year = {2000},
month = {July},
volume = {1},
number = {1},
pages = {77--111}}
[9] @inproceedings{Schewe21,
author = {K.-D. Schewe},
title = {Computation on Structures: Behavioural Theory, Logic, Complexity},
booktitle = {Logic, Computation and Rigorous Methods. Essays Dedicated to Egon B\&amp;quot;orger
on the Occasion of His 75th Birthday},
editor = {A.Raschke and E. Riccobene and K.-D. Schewe},
series = {Lecture Notes in Computer Science},
volume = {1275},
publisher = {Springer},
pages = {266--282},
year = {2021}
}
&lt;/code>&lt;/pre></description></item><item><title>Alloy</title><link>/method/alloy/</link><pubDate>Wed, 16 Jun 2021 00:00:00 +0000</pubDate><guid>/method/alloy/</guid><description>&lt;p>The Alloy language can be used to describe structures based on a collection of constraints. This created Alloy model can then be analyzed by the Alloy Analyzer, a solver that finds concrete structures that satisfy the constraints defined in the Alloy model.
The analysis can be used to generate sample structures or to check properties of these structures by trying to generate counterexamples. Alloy is based on the Z specification language and Tarski&amp;rsquo;s relational calculus.&lt;/p>
&lt;p>&lt;a href="http://alloytools.org/">http://alloytools.org/&lt;/a>&lt;/p></description></item><item><title>Classical B</title><link>/method/b/</link><pubDate>Wed, 16 Jun 2021 00:00:00 +0000</pubDate><guid>/method/b/</guid><description>&lt;p>Classical B (or just B) focuses on a tool-based refinement of a formal specification to code. It is based on the Z notation but slightly more low-level. In B a system consists of an abstract machine in which the modeler specifies the goal of the system. Via several refinement steps, this abstract goal is enhanced by more details on a less abstract level by adding details about data structures and algorithms that define how the goal is achieved.
All steps are proven correct until a deterministic version (the implementation) is reached.&lt;/p>
&lt;p>&lt;a href="https://methode-b.com">https://methode-b.com&lt;/a>&lt;/p></description></item><item><title>Event-B</title><link>/method/event-b/</link><pubDate>Wed, 16 Jun 2021 00:00:00 +0000</pubDate><guid>/method/event-b/</guid><description>&lt;p>Event-B is an evolution of (classical) B with a simpler notation. Similar to B a system is modeled by different abstraction levels that are connected by a rigorous refinement proven correct. Whereas the B-method is intended to the development of correct-by-construction software, the purpose of Event-B is to model full systems (including hardware and operation environment). These two languages share almost the same mathematical language.&lt;/p>
&lt;p>&lt;a href="http://www.event-b.org/">http://www.event-b.org/&lt;/a>&lt;/p></description></item><item><title>Temporal Logic of Actions (TLA)</title><link>/method/tla/</link><pubDate>Wed, 16 Jun 2021 00:00:00 +0000</pubDate><guid>/method/tla/</guid><description>&lt;p>TLA+ (Temporal Logic of Actions) was developed by Leslie Lamport to model, document, and verify especially concurrent and distributed systems. The language aims for defining the set of all correct system behaviors. It is organized in modules that contain a definition of states and (conditional) state transitions in form of steps. A &amp;ldquo;next-state-relations&amp;rdquo; defines how variables can change in any step. Similar to Z, B, and Event-B TLA+ is based on the Zermelo-Fraenkel set theory, but extended with built-in temporal logic operators.&lt;/p>
&lt;p>&lt;a href="http://lamport.azurewebsites.net/tla/tla.html">http://lamport.azurewebsites.net/tla/tla.html&lt;/a>&lt;/p></description></item><item><title>Vienna Development Method (VDM)</title><link>/method/vdm/</link><pubDate>Wed, 16 Jun 2021 00:00:00 +0000</pubDate><guid>/method/vdm/</guid><description>&lt;p>In the Vienna Development Method (VDM) models consist of a rich representation of data on which a system operates, together with the functionality that should be executed on these data structures. Besides the internal data also external input/output data is considered in the models.&lt;/p>
&lt;p>The functional behavior can be either defined abstract by pre- and postconditions or explicitly by specific state-based operations. The precise mathematical semantics of these definitions allows for a wide range of analyses, e.g. static analysis, testing or proof of properties of the sytem.&lt;/p>
&lt;p>&lt;a href="https://www.overturetool.org/method/">https://www.overturetool.org/method/&lt;/a>&lt;/p></description></item><item><title>Z Notation</title><link>/method/z/</link><pubDate>Wed, 16 Jun 2021 00:00:00 +0000</pubDate><guid>/method/z/</guid><description>&lt;p>Z is the &amp;ldquo;ultimate language&amp;rdquo; as stated by
&lt;a href="https://en.wikipedia.org/wiki/Jean-Raymond_Abrial" target="_blank" rel="noopener">Jean-Raymond Abrial&lt;/a> who invented this formal specification language in 1977. This language aims for a precise and clear specification of computer-based systems based on the Zermelo-Fraenkel set theory, lambda calculus, and first-order predicate logic. The main elements of Z are so-called &amp;ldquo;schemata&amp;rdquo; that consist of typed variables and constraints on the assignment of these. Z provides a standardized catalogue of often used mathematical functions and predicates.&lt;/p>
&lt;p>&lt;a href="http://www.zuser.org/">http://www.zuser.org/&lt;/a>&lt;/p></description></item></channel></rss>